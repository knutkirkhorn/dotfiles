#!/usr/bin/env bash

function gb() {
	git add package.json
	git add package-lock.json
	git commit -m "Bump dependencies"
}

# Create a directory, navigate into it, initialize npm and open VS Code
function mkdc() {
	# Check if directory already exists
	# Throw an error if it does
	if [ -d "$@" ]; then
		echo "Directory already exists"
		return 1
	fi

	mkdir -p "$@" && cd "$@" && npm init -y && code .
}

# Install npm dependencies and add `@latest` to each dependency
function nil() {
	packages=""

	for package in "$@"; do
		# Remove existing "@latest" if present
		package="${package/@latest/}"

		# Append "@latest" to each package
		package="$package@latest"

		packages="$packages$package "
	done

	# npm i $packages
	echo "TODO: buggy - use 'ncu' CLI instead (bun add -g npm-check-updates)"
}

# Install npm dev dependencies and add `@latest` to each dependency
function nidl() {
	packages=""

	for package in "$@"; do
		# Remove existing "@latest" if present
		package="${package/@latest/}"

		# Append "@latest" to each package
		package="$package@latest"

		packages="$packages$package "
	done

	# npm i -D $packages
	echo "TODO: buggy - use 'ncu' CLI instead (bun add -g npm-check-updates)"
}

function sqlpretty() {
	# Really dumb CLI function that uses the clipboard and removes:
	# - '\n'
	# - '\' in front of '"'
	# The output is saved back to the clipboard

	echo "$(pbpaste | tr -d '\n' | sed 's/\\"/"/g')" | pbcopy
}

function update-shadcn-components() {
	# Check if components/ui directory exists
	if [ ! -d "components/ui" ]; then
		echo "Error: components/ui directory not found"
		return 1
	fi

	# Get all .tsx files in the directory and join them with spaces
	components=$(find components/ui -name "*.tsx" -exec basename {} .tsx \; | tr '\n' ' ' | sed 's/ $//')

	# Check if any components were found
	if [ -z "$components" ]; then
		echo "No .tsx files found in components/ui"
		return 1
	fi

	# Run the shadcn add command with all components
	echo "Updating components: $components"
	eval "npx shadcn@latest add $components --overwrite"

	echo "Updated components"

	# Run ESLint and Prettier on the updated files
	echo "Running ESLint with auto-fix on components/ui..."
	npx eslint --fix "components/ui/**/*.{ts,tsx}"

	echo "Running Prettier on components/ui..."
	npx prettier --write "components/ui/**/*.{ts,tsx}"

	echo "Done! Components updated, linted and formatted."
}

function open-gitlab-pr() {
	if ! command -v git >/dev/null 2>&1; then
		echo "Error: git is required"
		return 1
	fi

	if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
		echo "Error: not inside a git repository"
		return 1
	fi

	if ! command -v open >/dev/null 2>&1; then
		echo "Error: open command not found"
		return 1
	fi

	urlencode() {
		local input="$1"
		local output=""
		local i char hex

		LC_ALL=C
		for ((i = 0; i < ${#input}; i++)); do
			char="${input:$i:1}"
			case "$char" in
			[a-zA-Z0-9.~_-]) output+="$char" ;;
			*)
				printf -v hex '%02X' "'$char"
				output+="%$hex"
				;;
			esac
		done

		printf '%s' "$output"
	}

	# Get and normalize git remote URL (supports HTTPS and SSH formats)
	git_remote_url="$(git remote get-url origin)"
	if [[ "$git_remote_url" =~ ^git@([^:]+):(.+)$ ]]; then
		git_remote_url="https://${BASH_REMATCH[1]}/${BASH_REMATCH[2]}"
	elif [[ "$git_remote_url" =~ ^ssh://git@([^/]+)/(.+)$ ]]; then
		git_remote_url="https://${BASH_REMATCH[1]}/${BASH_REMATCH[2]}"
	fi
	git_remote_url="${git_remote_url%.git}"

	git_branch_name="$(git branch --show-current)"
	if [ -z "$git_branch_name" ]; then
		echo "Error: could not determine current branch"
		return 1
	fi

	default_branch="$(git symbolic-ref --quiet --short refs/remotes/origin/HEAD 2>/dev/null | sed 's#^origin/##')"
	if [ -z "$default_branch" ]; then
		if git show-ref --verify --quiet refs/remotes/origin/main; then
			default_branch="main"
		elif git show-ref --verify --quiet refs/remotes/origin/master; then
			default_branch="master"
		else
			echo "Error: could not determine origin default branch"
			return 1
		fi
	fi

	commits_ahead="$(git rev-list --count "${default_branch}..HEAD")"

	# Check if there is only 1 commit in the current branch
	# If so, use the commit message as the PR title
	if [ "$commits_ahead" -eq 1 ]; then
		# Set the PR title to the last commit message
		pr_title="$(git log -1 --pretty=%B | tr '\n' ' ' | sed 's/[[:space:]]\+/ /g; s/^[[:space:]]*//; s/[[:space:]]*$//')"
	else
		# Convert the branch name to a title
		# - Remove everything before and including the first "/" in the branch name
		#   => This will for example remove "feature/" from "feature/my-feature"
		# - Replace dashes ("-") with URL encoded spaces ("%20")
		# - Capitalize the first letter at the start
		pr_title="$(echo "$git_branch_name" | sed 's#.*/##; s/-/ /g' | awk '{print toupper(substr($0,1,1)) substr($0,2)}')"
	fi

	# Open the PR in the browser
	encoded_branch="$(urlencode "$git_branch_name")"
	encoded_title="$(urlencode "$pr_title")"
	gitlab_pr_url="${git_remote_url}/-/merge_requests/new?merge_request%5Bsource_branch%5D=${encoded_branch}&merge_request%5Btitle%5D=${encoded_title}"
	open "$gitlab_pr_url"
}
